
RFC ADS Web Services
====================


This document proposes how to organize ADS internal as well as external
services. The crucial components here are:

  - user database (users)
  - applications (internal/external do ADS)
  - authentication server
  - authorization mechanism


User Database
=============

The User Database holds information such as:

	* id (numerical value)
	* email
	* password (encrypted)
	* last_login_at (time)
	* last_login_ip
	* registered_at (time)
	* login_count

The 'email' value is unique, as well as 'id'. Password is stored in encrypted
form to make it harder to attackers when the user db becomes compromised.

Other information are meant to track the activity of the user (purely for the
login system purposes). Other various information about users is stored
separately.

The User is also called 'RESOURCE OWNER' - every user owns herself (information
about the account etc) and we can give each user specialized privileges. E.g.
user 'montysolr@adslabs.org' can have privileges to use API (and can grant 
other clients right to use the API - more on that below).


Authentication server
=====================

We have a dedicated web service which provides the following endpoints:

	/register - to create a new user account
	/login - to authenticate existing user using email+password
	/logout	- to logout user (close the session)
	/reset - to reset the password (once the reset email has been generated)
	/confirm - a page where new users go (after /register->confirmation email
	           dance)
	/change - to change the password
	

This service needs to be accessed over HTTPS.

The same service also provide OATH2 authorization. It exposes user accounts
to other OAuth clients. But it also acts as OAuth client - it can authenticate
users using 3rd party service (e.g. users who have accounts with Google, Github,
Twitter etc). For every one of these users, the authentication service will
create a unique record (unique by their email).

The authentication server exposes ADS Classic accounts (ie. it can authenticate
users against the ADS Classic) - this is similar to 3rd party services; the
difference is that we are using proprietary ADS Classic protocol (and it is only
a fallback - ADS Classic user accounts should go away).


Clients
=======

Client is an application 'which wants to access certain resource'.

We do not distinguish internal/external applications. Each application must
use OAUTH2 mechanism to access certain resource.

This means that every application needs to obtain 'access_token' with
which it can identify itself (more on that in the section on OAUTH2)

Examples of applications are:

	* bumblebee client (serving data to bumblebee frontend)
	* python script accessing/updating user profile
	* ruby script accessing contents of a private library of user X


OAuth2: server
==============

ADS has a web service accessible over HTTPS which distributes 'access_tokens'
to clients. Clients use those to open doors to other resources. These are
the endpoints:

	/oauth2/token - the server will distribute 'access_tokens' from here
	/oauth2/error - a customized error message

In addition to these 'client' endpoints, the server also provides 'settings'
endpoints (accessible from user profile page)

	[profile]/oauth2/application/new - to create a new oauth2 application
	[profile]/oauth2/token - to generate a personal access token

	

There exist multiple workflows/scenarios, we'll use the following two:

	1. personal access token

		This is a secret key generated by a user. It never expires.
		User needs to give this secret to the application (client).
		Client will then use this 'personal access token' to obtain
		the 'ticket'.

		This authentication mechanism SHOULD BE USED ONLY VERY 
		RARELY! For example, for our internal ADS applications
		that run in safe (protected) environment.

	2. application key
		
		This is a secret key generated by a user _for specific
		application_. The application has:

			* name
			* secret key
			* url
			* description
			* scope (more on that later)

		This is the default authentication mechanism. We'll use
		this to enable all sorts of clients/services.

		An example: 
			1. login as 'adsgut@adslabs.org'
			2. go to profile - 'new oauth application'
			3. fill in the form details (save)
				redirect_url: http://somewhere.org/authorized
				scope =  user:private_library
			4. copy the generated client secret and give it
			   to the client (i.e. python script)

			
			Later on, somewhere on the internet, the 'client'
			initiates the OAuth2 dance:

				1. contacts our oauth2 server (sending secret)
				2. the oauth2 server redirects user to
				   out /login page
				3. user authenticates and is presented with
				   a form that asks to 'grant privileges'
				   to the application
				4. user 'John Doe' confirms
				5. oauth2 server sends tokens to:
				   http://somewhere.org/authorized
				6. after this point, the 'client' can access
				   API resources that are marked (scoped) as
				   'user:private_library' - and in fact -
				   the private library backend thinks that
				   the requests were sent by the user 'John Doe'
				   because this user will be logged in for 
				   every request
	


Web service: user profile
=========================

This dedicated service stores information about the user.


TODO:
=====

- there is a confusion about the user account and how the oauth 
  client login works. each token is tight to a given user 
  account (e.g. montysolr@adslabs.org)

	now: how do we avoid the login isssue?

  	- we could provide 'autologin' for our internal applications
	- or give them personal access token

	and also: how do we grant a client 'access_token' to
		use e.g. user:private_library?

		- do we generate applications on the fly?
		- do we genrate only one client application and give
		  it a scope 'user:private_library' and then mask
		  as user 'John Doe' after oauth2 is done?
